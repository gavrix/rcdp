<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>ViewModel</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
	      <div class="header">
	        <h1 class="title"><a href="/">Reactive Cocoa Design Patterns</a>
	        	<span style="visibility:hidden;"> Tweak a single line into justifying </span>
	        </h1>
	        <!-- <a class="extra" href="/">home</a> -->
	      </div>

	      <h1>ViewModel</h1>
<p class="post_date"> March 28, 2014 </p>

<p>This is the first topic in this blog, and since ViewModel is really a center component in <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a> pattern, which in turn is recommended to be used along with FRP, I decided to start this blog series with it. Why is MVVM so recommended for FRP? Well, these are my thoughts.</p>

<h3>What is ViewModel?</h3>

<p>In short, it&#39;s a piece of data representation logic. Or piece of functionality associated with the data in any way. You rarely represent the data backing your app to the user <em>exactly</em> the way this data is stored, most likely you somehow transform it first. Say, you store a date in one of machine formats, but show to the user human-friendly formatted string. That&#39;s pretty much what ViewModel is for: it takes model (or any data assumed as model) and <em>transforms</em> it, <em>denormalizes</em> it, to exact form to fill in the UI. ViewModel actually holds not only transformations but also <em>actions</em> associated with the model. We&#39;ll see how actions on model can be stored in ViewModel later.</p>

<h3>Why ViewModel?</h3>

<p>So, why ViewModel is so convenient to use with FRP and ReactiveCocoa? Well, because data <em>transformations</em> I mentioned are easily described as signal pipelines in declarative manner. Here&#39;s a very simple example:</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">dateString</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">Model</span> <span class="o">*</span><span class="n">model</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dateString</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">date</span><span class="p">)</span> <span class="n">map</span><span class="o">:^</span><span class="kt">id</span> <span class="p">(</span><span class="n">NSDate</span> <span class="o">*</span><span class="n">date</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="p">[</span><span class="n">dateFormatter</span> <span class="n">setDateFormat</span><span class="o">:</span><span class="s">@&quot;yyyy-MM-dd&quot;</span><span class="p">];</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="n">stringFromDate</span><span class="o">:</span><span class="n">date</span><span class="p">];</span>
<span class="p">}];</span>
</code></pre></div>
<p>In this example, whenever `<code>model</code> property of our ViewModel object, or model&#39;s <code>date</code> property, changes - <code>dateString</code> is <em>automatically</em> populated with corresponding value. We created an invisible connection between them. That&#39;s why it&#39;s called reactive: two properties are now in relationships so that changes to one of them reactively affects the other one.</p>

<h3>Actions in ViewModel</h3>

<p>I mentioned that we may even incorporate <em>actions</em> in ViewModel using ReactiveCocoa&#39;s features: by creating signal that perform those actions upon subscription and sends results to a subscriber. I&#39;ll cover this case in more details a special post. There is also a convenient component <code>RACCommand</code> which basically manages creation of signals and subscribing to them, handles execution in serial and concurrent mode as well as <code>enabled</code> state.</p>

<h3>Decoupling and compounding ViewModels.</h3>

<p>It&#39;s a very important feature of any piece of software - to be easily decoupled. Most of the time particular ViewModel serving a whole screen of the app does more than one atomic thing. Now imaging that another ViewModel serving another view has something in common with this one. In this scenario ViewModels can be refactored so that common functionality is moved into a third special ViewModel. This let us have more granular and less spaghetti dependent code. How to reuse common sub-ViewMode? Simply make it as property of another ViewModel and connect inputs and outputs accordingly:</p>
<div class="highlight"><pre><code class="objc language-objc" data-lang="objc"><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">SubViewModel</span> <span class="o">*</span><span class="n">subViewModel</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">Model</span> <span class="o">*</span><span class="n">inputModel</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">outputValue</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//tune subViewModel</span>
        <span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">subViewModel</span><span class="p">.</span><span class="n">model</span><span class="p">)</span> <span class="o">=</span> <span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inputModel</span><span class="p">);</span>

        <span class="c1">//tune output</span>
        <span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">outputValue</span><span class="p">)</span> <span class="o">=</span> <span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">subViewModel</span><span class="p">.</span><span class="n">itsOutputValue</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3>Testability</h3>

<p>No matter whether you practice TDD, or simply cover your code with integrational tests, having code covered is a must these days. Apparently, ViewModels are very convenient pattern to cover with tests, since it has strongly formalized inputs and outputs. Tests have straightforward pattern: set arbitrary inputs of your choice and check outputs for expected values.</p>

<p>ViewModels, by having use of FRP, particular RectiveCocoa, make it clearer and more straightforward how to implement functionality needed. It doesn&#39;t mean you have to write less code â€” no, computers won&#39;t do your job. But it definitely makes it clearer. The clearer you understand what you need to do, the less mistakes you make. And that is pretty much the main advantage FRP and MVVM so damn good: it allows you to make less mistakes.</p>








			<div class="footer">
				Created by Sergey Gavrilyuk <a class="extra" href="https://twitter.com/octogavrix">@octogavrix</a>
			</div>
		</div>
    </body>
</html>
